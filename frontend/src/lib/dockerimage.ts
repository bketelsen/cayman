// Code generated by tygo. DO NOT EDIT.

//////////
// source: delete_response.go

/**
 * DeleteResponse delete response
 * swagger:model DeleteResponse
 */
export interface DeleteResponse {
    /**
     * The image ID of an image that was deleted
     */
    Deleted?: string;
    /**
     * The image ID of an image that was untagged
     */
    Untagged?: string;
}

//////////
// source: image.go

/**
 * Metadata contains engine-local data about the image.
 */
export interface Metadata {
    /**
     * LastTagTime is the date and time at which the image was last tagged.
     */
    LastTagTime?: string;
}
/**
 * PruneReport contains the response for Engine API:
 * POST "/images/prune"
 */
export interface PruneReport {
    ImagesDeleted: DeleteResponse[];
    SpaceReclaimed: number /* uint64 */;
}
/**
 * LoadResponse returns information to the client about a load process.
 * TODO(thaJeztah): remove this type, and just use an io.ReadCloser
 * This type was added in https://github.com/moby/moby/pull/18878, related
 * to https://github.com/moby/moby/issues/19177;
 * Make docker load to output json when the response content type is json
 * Swarm hijacks the response from docker load and returns JSON rather
 * than plain text like the Engine does. This makes the API library to return
 * information to figure that out.
 * However the "load" endpoint unconditionally returns JSON;
 * https://github.com/moby/moby/blob/7b9d2ef6e5518a3d3f3cc418459f8df786cfbbd1/api/server/router/image/image_routes.go#L248-L255
 * PR https://github.com/moby/moby/pull/21959 made the response-type depend
 * on whether "quiet" was set, but this logic got changed in a follow-up
 * https://github.com/moby/moby/pull/25557, which made the JSON response-type
 * unconditionally, but the output produced depend on whether"quiet" was set.
 * We should deprecated the "quiet" option, as it's really a client
 * responsibility.
 */
export interface LoadResponse {
    /**
     * Body must be closed to avoid a resource leak
     */
    Body: any /* io.ReadCloser */;
    JSON: boolean;
}

//////////
// source: image_history.go

/**
 * HistoryResponseItem individual image layer information in response to ImageHistory operation
 * swagger:model HistoryResponseItem
 */
export interface HistoryResponseItem {
    /**
     * comment
     * Required: true
     */
    Comment: string;
    /**
     * created
     * Required: true
     */
    Created: number /* int64 */;
    /**
     * created by
     * Required: true
     */
    CreatedBy: string;
    /**
     * Id
     * Required: true
     */
    Id: string;
    /**
     * size
     * Required: true
     */
    Size: number /* int64 */;
    /**
     * tags
     * Required: true
     */
    Tags: string[];
}

//////////
// source: image_inspect.go

/**
 * RootFS returns Image's RootFS description including the layer IDs.
 */
export interface RootFS {
    Type?: string;
    Layers?: string[];
}
/**
 * InspectResponse contains response of Engine API:
 * GET "/images/{name:.*}/json"
 */
export interface InspectResponse {
    /**
     * ID is the content-addressable ID of an image.
     * This identifier is a content-addressable digest calculated from the
     * image's configuration (which includes the digests of layers used by
     * the image).
     * Note that this digest differs from the `RepoDigests` below, which
     * holds digests of image manifests that reference the image.
     */
    Id: string;
    /**
     * RepoTags is a list of image names/tags in the local image cache that
     * reference this image.
     * Multiple image tags can refer to the same image, and this list may be
     * empty if no tags reference the image, in which case the image is
     * "untagged", in which case it can still be referenced by its ID.
     */
    RepoTags: string[];
    /**
     * RepoDigests is a list of content-addressable digests of locally available
     * image manifests that the image is referenced from. Multiple manifests can
     * refer to the same image.
     * These digests are usually only available if the image was either pulled
     * from a registry, or if the image was pushed to a registry, which is when
     * the manifest is generated and its digest calculated.
     */
    RepoDigests: string[];
    /**
     * Parent is the ID of the parent image.
     * Depending on how the image was created, this field may be empty and
     * is only set for images that were built/created locally. This field
     * is empty if the image was pulled from an image registry.
     */
    Parent: string;
    /**
     * Comment is an optional message that can be set when committing or
     * importing the image.
     */
    Comment: string;
    /**
     * Created is the date and time at which the image was created, formatted in
     * RFC 3339 nano-seconds (time.RFC3339Nano).
     * This information is only available if present in the image,
     * and omitted otherwise.
     */
    Created?: string;
    /**
     * Container is the ID of the container that was used to create the image.
     * Depending on how the image was created, this field may be empty.
     * Deprecated: this field is omitted in API v1.45, but kept for backward compatibility.
     */
    Container?: string;
    /**
     * ContainerConfig is an optional field containing the configuration of the
     * container that was last committed when creating the image.
     * Previous versions of Docker builder used this field to store build cache,
     * and it is not in active use anymore.
     * Deprecated: this field is omitted in API v1.45, but kept for backward compatibility.
     */
    ContainerConfig?: any /* container.Config */;
    /**
     * DockerVersion is the version of Docker that was used to build the image.
     * Depending on how the image was created, this field may be empty.
     */
    DockerVersion: string;
    /**
     * Author is the name of the author that was specified when committing the
     * image, or as specified through MAINTAINER (deprecated) in the Dockerfile.
     */
    Author: string;
    Config?: any /* container.Config */;
    /**
     * Architecture is the hardware CPU architecture that the image runs on.
     */
    Architecture: string;
    /**
     * Variant is the CPU architecture variant (presently ARM-only).
     */
    Variant?: string;
    /**
     * OS is the Operating System the image is built to run on.
     */
    Os: string;
    /**
     * OsVersion is the version of the Operating System the image is built to
     * run on (especially for Windows).
     */
    OsVersion?: string;
    /**
     * Size is the total size of the image including all layers it is composed of.
     */
    Size: number /* int64 */;
    /**
     * VirtualSize is the total size of the image including all layers it is
     * composed of.
     * Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
     */
    VirtualSize?: number /* int64 */;
    /**
     * GraphDriver holds information about the storage driver used to store the
     * container's and image's filesystem.
     */
    GraphDriver: any /* storage.DriverData */;
    /**
     * RootFS contains information about the image's RootFS, including the
     * layer IDs.
     */
    RootFS: RootFS;
    /**
     * Metadata of the image in the local cache.
     * This information is local to the daemon, and not part of the image itself.
     */
    Metadata: Metadata;
    /**
     * Descriptor is the OCI descriptor of the image target.
     * It's only set if the daemon provides a multi-platform image store.
     * WARNING: This is experimental and may change at any time without any backward
     * compatibility.
     */
    Descriptor?: any /* ocispec.Descriptor */;
    /**
     * Manifests is a list of image manifests available in this image. It
     * provides a more detailed view of the platform-specific image manifests or
     * other image-attached data like build attestations.
     * Only available if the daemon provides a multi-platform image store, the client
     * requests manifests AND does not request a specific platform.
     * WARNING: This is experimental and may change at any time without any backward
     * compatibility.
     */
    Manifests?: ManifestSummary[];
}

//////////
// source: manifest.go

export type ManifestKind = string;
export const ManifestKindImage: ManifestKind = "image";
export const ManifestKindAttestation: ManifestKind = "attestation";
export const ManifestKindUnknown: ManifestKind = "unknown";
export interface ManifestSummary {
    /**
     * ID is the content-addressable ID of an image and is the same as the
     * digest of the image manifest.
     * Required: true
     */
    ID: string;
    /**
     * Descriptor is the OCI descriptor of the image.
     * Required: true
     */
    Descriptor: any /* ocispec.Descriptor */;
    /**
     * Indicates whether all the child content (image config, layers) is
     * fully available locally
     * Required: true
     */
    Available: boolean;
    /**
     * Size is the size information of the content related to this manifest.
     * Note: These sizes only take the locally available content into account.
     * Required: true
     */
    Size: {
        /**
         * Content is the size (in bytes) of all the locally present
         * content in the content store (e.g. image config, layers)
         * referenced by this manifest and its children.
         * This only includes blobs in the content store.
         */
        Content: number /* int64 */;
        /**
         * Total is the total size (in bytes) of all the locally present
         * data (both distributable and non-distributable) that's related to
         * this manifest and its children.
         * This equal to the sum of [Content] size AND all the sizes in the
         * [Size] struct present in the Kind-specific data struct.
         * For example, for an image kind (Kind == ManifestKindImage),
         * this would include the size of the image content and unpacked
         * image snapshots ([Size.Content] + [ImageData.Size.Unpacked]).
         */
        Total: number /* int64 */;
    };
    /**
     * Kind is the kind of the image manifest.
     * Required: true
     */
    Kind: ManifestKind;
    /**
     * Present only if Kind == ManifestKindImage.
     */
    ImageData?: ImageProperties;
    /**
     * Present only if Kind == ManifestKindAttestation.
     */
    AttestationData?: AttestationProperties;
}
export interface ImageProperties {
    /**
     * Platform is the OCI platform object describing the platform of the image.
     * Required: true
     */
    Platform: any /* ocispec.Platform */;
    Size: {
        /**
         * Unpacked is the size (in bytes) of the locally unpacked
         * (uncompressed) image content that's directly usable by the containers
         * running this image.
         * It's independent of the distributable content - e.g.
         * the image might still have an unpacked data that's still used by
         * some container even when the distributable/compressed content is
         * already gone.
         * Required: true
         */
        Unpacked: number /* int64 */;
    };
    /**
     * Containers is an array containing the IDs of the containers that are
     * using this image.
     * Required: true
     */
    Containers: string[];
}
export interface AttestationProperties {
    /**
     * For is the digest of the image manifest that this attestation is for.
     */
    For: any /* digest.Digest */;
}

//////////
// source: opts.go

/**
 * ImportSource holds source information for ImageImport
 */
export interface ImportSource {
    Source: any /* io.Reader */; // Source is the data to send to the server to create this image from. You must set SourceName to "-" to leverage this.
    SourceName: string; // SourceName is the name of the image to pull. Set to "-" to leverage the Source attribute.
}
/**
 * ImportOptions holds information to import images from the client host.
 */
export interface ImportOptions {
    Tag: string; // Tag is the name to tag this image with. This attribute is deprecated.
    Message: string; // Message is the message to tag the image with
    Changes: string[]; // Changes are the raw changes to apply to this image
    Platform: string; // Platform is the target platform of the image
}
/**
 * CreateOptions holds information to create images.
 */
export interface CreateOptions {
    RegistryAuth: string; // RegistryAuth is the base64 encoded credentials for the registry.
    Platform: string; // Platform is the target platform of the image if it needs to be pulled from the registry.
}
/**
 * PullOptions holds information to pull images.
 */
export interface PullOptions {
    All: boolean;
    RegistryAuth: string; // RegistryAuth is the base64 encoded credentials for the registry
    /**
     * PrivilegeFunc is a function that clients can supply to retry operations
     * after getting an authorization error. This function returns the registry
     * authentication header value in base64 encoded format, or an error if the
     * privilege request fails.
     * For details, refer to [github.com/docker/docker/api/types/registry.RequestAuthConfig].
     */
    PrivilegeFunc: any;
    Platform: string;
}
/**
 * PushOptions holds information to push images.
 */
export interface PushOptions {
    All: boolean;
    RegistryAuth: string; // RegistryAuth is the base64 encoded credentials for the registry
    /**
     * PrivilegeFunc is a function that clients can supply to retry operations
     * after getting an authorization error. This function returns the registry
     * authentication header value in base64 encoded format, or an error if the
     * privilege request fails.
     * For details, refer to [github.com/docker/docker/api/types/registry.RequestAuthConfig].
     */
    PrivilegeFunc: any;
    /**
     * Platform is an optional field that selects a specific platform to push
     * when the image is a multi-platform image.
     * Using this will only push a single platform-specific manifest.
     */
    Platform?: any /* ocispec.Platform */;
}
/**
 * ListOptions holds parameters to list images with.
 */
export interface ListOptions {
    /**
     * All controls whether all images in the graph are filtered, or just
     * the heads.
     */
    All: boolean;
    /**
     * Filters is a JSON-encoded set of filter arguments.
     */
    Filters: any /* filters.Args */;
    /**
     * SharedSize indicates whether the shared size of images should be computed.
     */
    SharedSize: boolean;
    /**
     * ContainerCount indicates whether container count should be computed.
     */
    ContainerCount: boolean;
    /**
     * Manifests indicates whether the image manifests should be returned.
     */
    Manifests: boolean;
}
/**
 * RemoveOptions holds parameters to remove images.
 */
export interface RemoveOptions {
    Force: boolean;
    PruneChildren: boolean;
}
/**
 * HistoryOptions holds parameters to get image history.
 */
export interface HistoryOptions {
    /**
     * Platform from the manifest list to use for history.
     */
    Platform?: any /* ocispec.Platform */;
}
/**
 * LoadOptions holds parameters to load images.
 */
export interface LoadOptions {
    /**
     * Quiet suppresses progress output
     */
    Quiet: boolean;
    /**
     * Platforms selects the platforms to load if the image is a
     * multi-platform image and has multiple variants.
     */
    Platforms: any /* ocispec.Platform */[];
}
export interface InspectOptions {
    /**
     * Manifests returns the image manifests.
     */
    Manifests: boolean;
    /**
     * Platform selects the specific platform of a multi-platform image to inspect.
     * This option is only available for API version 1.49 and up.
     */
    Platform?: any /* ocispec.Platform */;
}
/**
 * SaveOptions holds parameters to save images.
 */
export interface SaveOptions {
    /**
     * Platforms selects the platforms to save if the image is a
     * multi-platform image and has multiple variants.
     */
    Platforms: any /* ocispec.Platform */[];
}

//////////
// source: summary.go

export interface Summary {
    /**
     * Number of containers using this image. Includes both stopped and running
     * containers.
     * This size is not calculated by default, and depends on which API endpoint
     * is used. `-1` indicates that the value has not been set / calculated.
     * Required: true
     */
    Containers: number /* int64 */;
    /**
     * Date and time at which the image was created as a Unix timestamp
     * (number of seconds since EPOCH).
     * Required: true
     */
    Created: number /* int64 */;
    /**
     * ID is the content-addressable ID of an image.
     * This identifier is a content-addressable digest calculated from the
     * image's configuration (which includes the digests of layers used by
     * the image).
     * Note that this digest differs from the `RepoDigests` below, which
     * holds digests of image manifests that reference the image.
     * Required: true
     */
    Id: string;
    /**
     * User-defined key/value metadata.
     * Required: true
     */
    Labels: { [key: string]: string};
    /**
     * ID of the parent image.
     * Depending on how the image was created, this field may be empty and
     * is only set for images that were built/created locally. This field
     * is empty if the image was pulled from an image registry.
     * Required: true
     */
    ParentId: string;
    /**
     * Descriptor is the OCI descriptor of the image target.
     * It's only set if the daemon provides a multi-platform image store.
     * WARNING: This is experimental and may change at any time without any backward
     * compatibility.
     */
    Descriptor?: any /* ocispec.Descriptor */;
    /**
     * Manifests is a list of image manifests available in this image.  It
     * provides a more detailed view of the platform-specific image manifests or
     * other image-attached data like build attestations.
     * WARNING: This is experimental and may change at any time without any backward
     * compatibility.
     */
    Manifests?: ManifestSummary[];
    /**
     * List of content-addressable digests of locally available image manifests
     * that the image is referenced from. Multiple manifests can refer to the
     * same image.
     * These digests are usually only available if the image was either pulled
     * from a registry, or if the image was pushed to a registry, which is when
     * the manifest is generated and its digest calculated.
     * Required: true
     */
    RepoDigests: string[];
    /**
     * List of image names/tags in the local image cache that reference this
     * image.
     * Multiple image tags can refer to the same image, and this list may be
     * empty if no tags reference the image, in which case the image is
     * "untagged", in which case it can still be referenced by its ID.
     * Required: true
     */
    RepoTags: string[];
    /**
     * Total size of image layers that are shared between this image and other
     * images.
     * This size is not calculated by default. `-1` indicates that the value
     * has not been set / calculated.
     * Required: true
     */
    SharedSize: number /* int64 */;
    /**
     * Total size of the image including all layers it is composed of.
     * Required: true
     */
    Size: number /* int64 */;
    /**
     * Total size of the image including all layers it is composed of.
     * Deprecated: this field is omitted in API v1.44, but kept for backward compatibility. Use Size instead.
     */
    VirtualSize?: number /* int64 */;
}
