// Code generated by tygo. DO NOT EDIT.

//////////
// source: change_type.go

/**
 * ChangeType Kind of change
 * Can be one of:
 * - `0`: Modified ("C")
 * - `1`: Added ("A")
 * - `2`: Deleted ("D")
 * swagger:model ChangeType
 */
export type ChangeType = number /* uint8 */;

//////////
// source: change_types.go

/**
 * ChangeModify represents the modify operation.
 */
export const ChangeModify: ChangeType = 0;
/**
 * ChangeAdd represents the add operation.
 */
export const ChangeAdd: ChangeType = 1;
/**
 * ChangeDelete represents the delete operation.
 */
export const ChangeDelete: ChangeType = 2;

//////////
// source: commit.go

/**
 * CommitResponse response for the commit API call, containing the ID of the
 * image that was produced.
 */
export type CommitResponse = any /* common.IDResponse */;

//////////
// source: config.go

/**
 * MinimumDuration puts a minimum on user configured duration.
 * This is to prevent API error on time unit. For example, API may
 * set 3 as healthcheck interval with intention of 3 seconds, but
 * Docker interprets it as 3 nanoseconds.
 */
export const MinimumDuration = 1 * any /* time.Millisecond */;
/**
 * StopOptions holds the options to stop or restart a container.
 */
export interface StopOptions {
    /**
     * Signal (optional) is the signal to send to the container to (gracefully)
     * stop it before forcibly terminating the container with SIGKILL after the
     * timeout expires. If not value is set, the default (SIGTERM) is used.
     */
    Signal?: string;
    /**
     * Timeout (optional) is the timeout (in seconds) to wait for the container
     * to stop gracefully before forcibly terminating it with SIGKILL.
     * - Use nil to use the default timeout (10 seconds).
     * - Use '-1' to wait indefinitely.
     * - Use '0' to not wait for the container to exit gracefully, and
     *   immediately proceeds to forcibly terminating the container.
     * - Other positive values are used as timeout (in seconds).
     */
    Timeout?: number /* int */;
}
/**
 * HealthConfig holds configuration settings for the HEALTHCHECK feature.
 */
export type HealthConfig = any /* dockerspec.HealthcheckConfig */;
/**
 * Config contains the configuration data about a container.
 * It should hold only portable information about the container.
 * Here, "portable" means "independent from the host we are running on".
 * Non-portable information *should* appear in HostConfig.
 * All fields added to this struct must be marked `omitempty` to keep getting
 * predictable hashes from the old `v1Compatibility` configuration.
 */
export interface Config {
    Hostname: string; // Hostname
    Domainname: string; // Domainname
    User: string; // User that will run the command(s) inside the container, also support user:group
    AttachStdin: boolean; // Attach the standard input, makes possible user interaction
    AttachStdout: boolean; // Attach the standard output
    AttachStderr: boolean; // Attach the standard error
    ExposedPorts?: any /* nat.PortSet */; // List of exposed ports
    Tty: boolean; // Attach standard streams to a tty, including stdin if it is not closed.
    OpenStdin: boolean; // Open stdin
    StdinOnce: boolean; // If true, close stdin after the 1 attached client disconnects.
    Env: string[]; // List of environment variable to set in the container
    Cmd: any /* strslice.StrSlice */; // Command to run when starting the container
    Healthcheck?: HealthConfig; // Healthcheck describes how to check the container is healthy
    ArgsEscaped?: boolean; // True if command is already escaped (meaning treat as a command line) (Windows specific).
    Image: string; // Name of the image as it was passed by the operator (e.g. could be symbolic)
    Volumes: { [key: string]: {
    }}; // List of volumes (mounts) used for the container
    WorkingDir: string; // Current directory (PWD) in the command will be launched
    Entrypoint: any /* strslice.StrSlice */; // Entrypoint to run when starting the container
    NetworkDisabled?: boolean; // Is network disabled
    /**
     * Mac Address of the container.
     * Deprecated: this field is deprecated since API v1.44. Use EndpointSettings.MacAddress instead.
     */
    MacAddress?: string;
    OnBuild: string[]; // ONBUILD metadata that were defined on the image Dockerfile
    Labels: { [key: string]: string}; // List of labels set to this container
    StopSignal?: string; // Signal to stop a container
    StopTimeout?: number /* int */; // Timeout (in seconds) to stop a container
    Shell?: any /* strslice.StrSlice */; // Shell for shell-form of RUN, CMD, ENTRYPOINT
}

//////////
// source: container.go

/**
 * ContainerUpdateOKBody OK response to ContainerUpdate operation
 * Deprecated: use [UpdateResponse]. This alias will be removed in the next release.
 */
export type ContainerUpdateOKBody = UpdateResponse;
/**
 * ContainerTopOKBody OK response to ContainerTop operation
 * Deprecated: use [TopResponse]. This alias will be removed in the next release.
 */
export type ContainerTopOKBody = TopResponse;
/**
 * PruneReport contains the response for Engine API:
 * POST "/containers/prune"
 */
export interface PruneReport {
    ContainersDeleted: string[];
    SpaceReclaimed: number /* uint64 */;
}
/**
 * PathStat is used to encode the header from
 * GET "/containers/{name:.*}/archive"
 * "Name" is the file or directory name.
 */
export interface PathStat {
    name: string;
    size: number /* int64 */;
    mode: any /* os.FileMode */;
    mtime: string;
    linkTarget: string;
}
/**
 * CopyToContainerOptions holds information
 * about files to copy into a container
 */
export interface CopyToContainerOptions {
    AllowOverwriteDirWithFile: boolean;
    CopyUIDGID: boolean;
}
/**
 * StatsResponseReader wraps an io.ReadCloser to read (a stream of) stats
 * for a container, as produced by the GET "/stats" endpoint.
 * The OSType field is set to the server's platform to allow
 * platform-specific handling of the response.
 * TODO(thaJeztah): remove this wrapper, and make OSType part of [StatsResponse].
 */
export interface StatsResponseReader {
    body: any /* io.ReadCloser */;
    ostype: string;
}
/**
 * MountPoint represents a mount point configuration inside the container.
 * This is used for reporting the mountpoints in use by a container.
 */
export interface MountPoint {
    /**
     * Type is the type of mount, see `Type<foo>` definitions in
     * github.com/docker/docker/api/types/mount.Type
     */
    Type?: any /* mount.Type */;
    /**
     * Name is the name reference to the underlying data defined by `Source`
     * e.g., the volume name.
     */
    Name?: string;
    /**
     * Source is the source location of the mount.
     * For volumes, this contains the storage location of the volume (within
     * `/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains
     * the source (host) part of the bind-mount. For `tmpfs` mount points, this
     * field is empty.
     */
    Source: string;
    /**
     * Destination is the path relative to the container root (`/`) where the
     * Source is mounted inside the container.
     */
    Destination: string;
    /**
     * Driver is the volume driver used to create the volume (if it is a volume).
     */
    Driver?: string;
    /**
     * Mode is a comma separated list of options supplied by the user when
     * creating the bind/volume mount.
     * The default is platform-specific (`"z"` on Linux, empty on Windows).
     */
    Mode: string;
    /**
     * RW indicates whether the mount is mounted writable (read-write).
     */
    RW: boolean;
    /**
     * Propagation describes how mounts are propagated from the host into the
     * mount point, and vice-versa. Refer to the Linux kernel documentation
     * for details:
     * https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
     * This field is not used on Windows.
     */
    Propagation: any /* mount.Propagation */;
}
/**
 * State stores container's running state
 * it's part of ContainerJSONBase and returned by "inspect" command
 */
export interface State {
    Status: string; // String representation of the container state. Can be one of "created", "running", "paused", "restarting", "removing", "exited", or "dead"
    Running: boolean;
    Paused: boolean;
    Restarting: boolean;
    OOMKilled: boolean;
    Dead: boolean;
    Pid: number /* int */;
    ExitCode: number /* int */;
    Error: string;
    StartedAt: string;
    FinishedAt: string;
    Health?: Health;
}
/**
 * Summary contains response of Engine API:
 * GET "/containers/json"
 */
export interface Summary {
    Id: string;
    Names: string[];
    Image: string;
    ImageID: string;
    ImageManifestDescriptor?: any /* ocispec.Descriptor */;
    Command: string;
    Created: number /* int64 */;
    Ports: Port[];
    SizeRw?: number /* int64 */;
    SizeRootFs?: number /* int64 */;
    Labels: { [key: string]: string};
    State: string;
    Status: string;
    HostConfig: {
        NetworkMode?: string;
        Annotations?: { [key: string]: string};
    };
    NetworkSettings?: NetworkSettingsSummary;
    Mounts: MountPoint[];
}
/**
 * ContainerJSONBase contains response of Engine API GET "/containers/{name:.*}/json"
 * for API version 1.18 and older.
 * TODO(thaJeztah): combine ContainerJSONBase and InspectResponse into a single struct.
 * The split between ContainerJSONBase (ContainerJSONBase) and InspectResponse (InspectResponse)
 * was done in commit 6deaa58ba5f051039643cedceee97c8695e2af74 (https://github.com/moby/moby/pull/13675).
 * ContainerJSONBase contained all fields for API < 1.19, and InspectResponse
 * held fields that were added in API 1.19 and up. Given that the minimum
 * supported API version is now 1.24, we no longer use the separate type.
 */
export interface ContainerJSONBase {
    Id: string;
    Created: string;
    Path: string;
    Args: string[];
    State?: State;
    Image: string;
    ResolvConfPath: string;
    HostnamePath: string;
    HostsPath: string;
    LogPath: string;
    Name: string;
    RestartCount: number /* int */;
    Driver: string;
    Platform: string;
    MountLabel: string;
    ProcessLabel: string;
    AppArmorProfile: string;
    ExecIDs: string[];
    HostConfig?: HostConfig;
    GraphDriver: any /* storage.DriverData */;
    SizeRw?: number /* int64 */;
    SizeRootFs?: number /* int64 */;
}
/**
 * InspectResponse is the response for the GET "/containers/{name:.*}/json"
 * endpoint.
 */
export interface InspectResponse {
    ContainerJSONBase?: ContainerJSONBase;
    Mounts: MountPoint[];
    Config?: Config;
    NetworkSettings?: NetworkSettings;
    /**
     * ImageManifestDescriptor is the descriptor of a platform-specific manifest of the image used to create the container.
     */
    ImageManifestDescriptor?: any /* ocispec.Descriptor */;
}

//////////
// source: create_request.go

/**
 * CreateRequest is the request message sent to the server for container
 * create calls. It is a config wrapper that holds the container [Config]
 * (portable) and the corresponding [HostConfig] (non-portable) and
 * [network.NetworkingConfig].
 */
export interface CreateRequest {
    Config?: Config;
    HostConfig?: HostConfig;
    NetworkingConfig?: any /* network.NetworkingConfig */;
}

//////////
// source: create_response.go

/**
 * CreateResponse ContainerCreateResponse
 * OK response to ContainerCreate operation
 * swagger:model CreateResponse
 */
export interface CreateResponse {
    /**
     * The ID of the created container
     * Required: true
     */
    Id: string;
    /**
     * Warnings encountered when creating the container
     * Required: true
     */
    Warnings: string[];
}

//////////
// source: errors.go


//////////
// source: exec.go

/**
 * ExecCreateResponse is the response for a successful exec-create request.
 * It holds the ID of the exec that was created.
 * TODO(thaJeztah): make this a distinct type.
 */
export type ExecCreateResponse = any /* common.IDResponse */;
/**
 * ExecOptions is a small subset of the Config struct that holds the configuration
 * for the exec feature of docker.
 */
export interface ExecOptions {
    User: string; // User that will run the command
    Privileged: boolean; // Is the container in privileged mode
    Tty: boolean; // Attach standard streams to a tty.
    ConsoleSize?: number /* uint */[]; // Initial console size [height, width]
    AttachStdin: boolean; // Attach the standard input, makes possible user interaction
    AttachStderr: boolean; // Attach the standard error
    AttachStdout: boolean; // Attach the standard output
    Detach: boolean; // Execute in detach mode
    DetachKeys: string; // Escape keys for detach
    Env: string[]; // Environment variables
    WorkingDir: string; // Working directory
    Cmd: string[]; // Execution commands and args
}
/**
 * ExecStartOptions is a temp struct used by execStart
 * Config fields is part of ExecConfig in runconfig package
 */
export interface ExecStartOptions {
    /**
     * ExecStart will first check if it's detached
     */
    Detach: boolean;
    /**
     * Check if there's a tty
     */
    Tty: boolean;
    /**
     * Terminal size [height, width], unused if Tty == false
     */
    ConsoleSize?: number /* uint */[];
}
/**
 * ExecAttachOptions is a temp struct used by execAttach.
 * TODO(thaJeztah): make this a separate type; ContainerExecAttach does not use the Detach option, and cannot run detached.
 */
export type ExecAttachOptions = ExecStartOptions;
/**
 * ExecInspect holds information returned by exec inspect.
 */
export interface ExecInspect {
    ID: string;
    ContainerID: string;
    Running: boolean;
    ExitCode: number /* int */;
    Pid: number /* int */;
}

//////////
// source: filesystem_change.go

/**
 * FilesystemChange Change in the container's filesystem.
 * swagger:model FilesystemChange
 */
export interface FilesystemChange {
    /**
     * kind
     * Required: true
     */
    Kind: ChangeType;
    /**
     * Path to file or directory that has changed.
     * Required: true
     */
    Path: string;
}

//////////
// source: health.go

/**
 * Health states
 */
export const NoHealthcheck = "none"; // Indicates there is no healthcheck
/**
 * Health states
 */
export const Starting = "starting"; // Starting indicates that the container is not yet ready
/**
 * Health states
 */
export const Healthy = "healthy"; // Healthy indicates that the container is running correctly
/**
 * Health states
 */
export const Unhealthy = "unhealthy"; // Unhealthy indicates that the container has a problem
/**
 * Health stores information about the container's healthcheck results
 */
export interface Health {
    Status: string; // Status is one of [Starting], [Healthy] or [Unhealthy].
    FailingStreak: number /* int */; // FailingStreak is the number of consecutive failures
    Log: (HealthcheckResult | undefined)[]; // Log contains the last few results (oldest first)
}
/**
 * HealthcheckResult stores information about a single run of a healthcheck probe
 */
export interface HealthcheckResult {
    Start: string; // Start is the time this check started
    End: string; // End is the time this check ended
    ExitCode: number /* int */; // ExitCode meanings: 0=healthy, 1=unhealthy, 2=reserved (considered unhealthy), else=error running probe
    Output: string; // Output from last check
}

//////////
// source: hostconfig.go

/**
 * CgroupnsMode represents the cgroup namespace mode of the container
 */
export type CgroupnsMode = string;
/**
 * cgroup namespace modes for containers
 */
export const CgroupnsModeEmpty: CgroupnsMode = "";
/**
 * cgroup namespace modes for containers
 */
export const CgroupnsModePrivate: CgroupnsMode = "private";
/**
 * cgroup namespace modes for containers
 */
export const CgroupnsModeHost: CgroupnsMode = "host";
/**
 * Isolation represents the isolation technology of a container. The supported
 * values are platform specific
 */
export type Isolation = string;
/**
 * Isolation modes for containers
 */
export const IsolationEmpty: Isolation = ""; // IsolationEmpty is unspecified (same behavior as default)
/**
 * Isolation modes for containers
 */
export const IsolationDefault: Isolation = "default"; // IsolationDefault is the default isolation mode on current daemon
/**
 * Isolation modes for containers
 */
export const IsolationProcess: Isolation = "process"; // IsolationProcess is process isolation mode
/**
 * Isolation modes for containers
 */
export const IsolationHyperV: Isolation = "hyperv"; // IsolationHyperV is HyperV isolation mode
/**
 * IpcMode represents the container ipc stack.
 */
export type IpcMode = string;
/**
 * IpcMode constants
 */
export const IPCModeNone: IpcMode = "none";
/**
 * IpcMode constants
 */
export const IPCModeHost: IpcMode = "host";
/**
 * IpcMode constants
 */
export const IPCModeContainer: IpcMode = "container";
/**
 * IpcMode constants
 */
export const IPCModePrivate: IpcMode = "private";
/**
 * IpcMode constants
 */
export const IPCModeShareable: IpcMode = "shareable";
/**
 * NetworkMode represents the container network stack.
 */
export type NetworkMode = string;
/**
 * UsernsMode represents userns mode in the container.
 */
export type UsernsMode = string;
/**
 * CgroupSpec represents the cgroup to use for the container.
 */
export type CgroupSpec = string;
/**
 * UTSMode represents the UTS namespace of the container.
 */
export type UTSMode = string;
/**
 * PidMode represents the pid namespace of the container.
 */
export type PidMode = string;
/**
 * DeviceRequest represents a request for devices from a device driver.
 * Used by GPU device drivers.
 */
export interface DeviceRequest {
    Driver: string; // Name of device driver
    Count: number /* int */; // Number of devices to request (-1 = All)
    DeviceIDs: string[]; // List of device IDs as recognizable by the device driver
    Capabilities: string[][]; // An OR list of AND lists of device capabilities (e.g. "gpu")
    Options: { [key: string]: string}; // Options to pass onto the device driver
}
/**
 * DeviceMapping represents the device mapping between the host and the container.
 */
export interface DeviceMapping {
    PathOnHost: string;
    PathInContainer: string;
    CgroupPermissions: string;
}
/**
 * RestartPolicy represents the restart policies of the container.
 */
export interface RestartPolicy {
    Name: RestartPolicyMode;
    MaximumRetryCount: number /* int */;
}
export type RestartPolicyMode = string;
export const RestartPolicyDisabled: RestartPolicyMode = "no";
export const RestartPolicyAlways: RestartPolicyMode = "always";
export const RestartPolicyOnFailure: RestartPolicyMode = "on-failure";
export const RestartPolicyUnlessStopped: RestartPolicyMode = "unless-stopped";
/**
 * LogMode is a type to define the available modes for logging
 * These modes affect how logs are handled when log messages start piling up.
 */
export type LogMode = string;
/**
 * Available logging modes
 */
export const LogModeUnset: LogMode = "";
/**
 * Available logging modes
 */
export const LogModeBlocking: LogMode = "blocking";
/**
 * Available logging modes
 */
export const LogModeNonBlock: LogMode = "non-blocking";
/**
 * LogConfig represents the logging configuration of the container.
 */
export interface LogConfig {
    Type: string;
    Config: { [key: string]: string};
}
/**
 * Ulimit is an alias for [units.Ulimit], which may be moving to a different
 * location or become a local type. This alias is to help transitioning.
 * Users are recommended to use this alias instead of using [units.Ulimit] directly.
 */
export type Ulimit = any /* units.Ulimit */;
/**
 * Resources contains container's resources (cgroups config, ulimits...)
 */
export interface Resources {
    /**
     * Applicable to all platforms
     */
    CpuShares: number /* int64 */; // CPU shares (relative weight vs. other containers)
    Memory: number /* int64 */; // Memory limit (in bytes)
    NanoCpus: number /* int64 */; // CPU quota in units of 10<sup>-9</sup> CPUs.
    /**
     * Applicable to UNIX platforms
     */
    CgroupParent: string; // Parent cgroup.
    BlkioWeight: number /* uint16 */; // Block IO weight (relative weight vs. other containers)
    BlkioWeightDevice: (any /* blkiodev.WeightDevice */ | undefined)[];
    BlkioDeviceReadBps: (any /* blkiodev.ThrottleDevice */ | undefined)[];
    BlkioDeviceWriteBps: (any /* blkiodev.ThrottleDevice */ | undefined)[];
    BlkioDeviceReadIOps: (any /* blkiodev.ThrottleDevice */ | undefined)[];
    BlkioDeviceWriteIOps: (any /* blkiodev.ThrottleDevice */ | undefined)[];
    CpuPeriod: number /* int64 */; // CPU CFS (Completely Fair Scheduler) period
    CpuQuota: number /* int64 */; // CPU CFS (Completely Fair Scheduler) quota
    CpuRealtimePeriod: number /* int64 */; // CPU real-time period
    CpuRealtimeRuntime: number /* int64 */; // CPU real-time runtime
    CpusetCpus: string; // CpusetCpus 0-2, 0,1
    CpusetMems: string; // CpusetMems 0-2, 0,1
    Devices: DeviceMapping[]; // List of devices to map inside the container
    DeviceCgroupRules: string[]; // List of rule to be added to the device cgroup
    DeviceRequests: DeviceRequest[]; // List of device requests for device drivers
    /**
     * KernelMemory specifies the kernel memory limit (in bytes) for the container.
     * Deprecated: kernel 5.4 deprecated kmem.limit_in_bytes.
     */
    KernelMemory?: number /* int64 */;
    KernelMemoryTCP?: number /* int64 */; // Hard limit for kernel TCP buffer memory (in bytes)
    MemoryReservation: number /* int64 */; // Memory soft limit (in bytes)
    MemorySwap: number /* int64 */; // Total memory usage (memory + swap); set `-1` to enable unlimited swap
    MemorySwappiness?: number /* int64 */; // Tuning container memory swappiness behaviour
    OomKillDisable?: boolean; // Whether to disable OOM Killer or not
    PidsLimit?: number /* int64 */; // Setting PIDs limit for a container; Set `0` or `-1` for unlimited, or `null` to not change.
    Ulimits: (Ulimit | undefined)[]; // List of ulimits to be set in the container
    /**
     * Applicable to Windows
     */
    CpuCount: number /* int64 */; // CPU count
    CpuPercent: number /* int64 */; // CPU percent
    IOMaximumIOps: number /* uint64 */; // Maximum IOps for the container system drive
    IOMaximumBandwidth: number /* uint64 */; // Maximum IO in bytes per second for the container system drive
}
/**
 * UpdateConfig holds the mutable attributes of a Container.
 * Those attributes can be updated at runtime.
 */
export interface UpdateConfig {
    /**
     * Contains container's resources (cgroups, ulimits)
     */
    Resources: Resources;
    RestartPolicy: RestartPolicy;
}
/**
 * HostConfig the non-portable Config structure of a container.
 * Here, "non-portable" means "dependent of the host we are running on".
 * Portable information *should* appear in Config.
 */
export interface HostConfig {
    /**
     * Applicable to all platforms
     */
    Binds: string[]; // List of volume bindings for this container
    ContainerIDFile: string; // File (path) where the containerId is written
    LogConfig: LogConfig; // Configuration of the logs for this container
    NetworkMode: NetworkMode; // Network mode to use for the container
    PortBindings: any /* nat.PortMap */; // Port mapping between the exposed port (container) and the host
    RestartPolicy: RestartPolicy; // Restart policy to be used for the container
    AutoRemove: boolean; // Automatically remove container when it exits
    VolumeDriver: string; // Name of the volume driver used to mount volumes
    VolumesFrom: string[]; // List of volumes to take from other container
    ConsoleSize: number /* uint */[]; // Initial console size (height,width)
    Annotations?: { [key: string]: string}; // Arbitrary non-identifying metadata attached to container and provided to the runtime
    /**
     * Applicable to UNIX platforms
     */
    CapAdd: any /* strslice.StrSlice */; // List of kernel capabilities to add to the container
    CapDrop: any /* strslice.StrSlice */; // List of kernel capabilities to remove from the container
    CgroupnsMode: CgroupnsMode; // Cgroup namespace mode to use for the container
    Dns: string[]; // List of DNS server to lookup
    DnsOptions: string[]; // List of DNSOption to look for
    DnsSearch: string[]; // List of DNSSearch to look for
    ExtraHosts: string[]; // List of extra hosts
    GroupAdd: string[]; // List of additional groups that the container process will run as
    IpcMode: IpcMode; // IPC namespace to use for the container
    Cgroup: CgroupSpec; // Cgroup to use for the container
    Links: string[]; // List of links (in the name:alias form)
    OomScoreAdj: number /* int */; // Container preference for OOM-killing
    PidMode: PidMode; // PID namespace to use for the container
    Privileged: boolean; // Is the container in privileged mode
    PublishAllPorts: boolean; // Should docker publish all exposed port for the container
    ReadonlyRootfs: boolean; // Is the container root filesystem in read-only
    SecurityOpt: string[]; // List of string values to customize labels for MLS systems, such as SELinux.
    StorageOpt?: { [key: string]: string}; // Storage driver options per container.
    Tmpfs?: { [key: string]: string}; // List of tmpfs (mounts) used for the container
    UTSMode: UTSMode; // UTS namespace to use for the container
    UsernsMode: UsernsMode; // The user namespace to use for the container
    ShmSize: number /* int64 */; // Total shm memory usage
    Sysctls?: { [key: string]: string}; // List of Namespaced sysctls used for the container
    Runtime?: string; // Runtime to use with this container
    /**
     * Applicable to Windows
     */
    Isolation: Isolation; // Isolation technology of the container (e.g. default, hyperv)
    /**
     * Contains container's resources (cgroups, ulimits)
     */
    Resources: Resources;
    /**
     * Mounts specs used by the container
     */
    Mounts?: any /* mount.Mount */[];
    /**
     * MaskedPaths is the list of paths to be masked inside the container (this overrides the default set of paths)
     */
    MaskedPaths: string[];
    /**
     * ReadonlyPaths is the list of paths to be set as read-only inside the container (this overrides the default set of paths)
     */
    ReadonlyPaths: string[];
    /**
     * Run a custom init inside the container, if null, use the daemon's configured settings
     */
    Init?: boolean;
}

//////////
// source: network_settings.go

/**
 * NetworkSettings exposes the network settings in the api
 */
export interface NetworkSettings {
    NetworkSettingsBase: NetworkSettingsBase;
    DefaultNetworkSettings: DefaultNetworkSettings;
    Networks: { [key: string]: any /* network.EndpointSettings */ | undefined};
}
/**
 * NetworkSettingsBase holds networking state for a container when inspecting it.
 */
export interface NetworkSettingsBase {
    Bridge: string; // Bridge contains the name of the default bridge interface iff it was set through the daemon --bridge flag.
    SandboxID: string; // SandboxID uniquely represents a container's network stack
    SandboxKey: string; // SandboxKey identifies the sandbox
    Ports: any /* nat.PortMap */; // Ports is a collection of PortBinding indexed by Port
    /**
     * HairpinMode specifies if hairpin NAT should be enabled on the virtual interface
     * Deprecated: This field is never set and will be removed in a future release.
     */
    HairpinMode: boolean;
    /**
     * LinkLocalIPv6Address is an IPv6 unicast address using the link-local prefix
     * Deprecated: This field is never set and will be removed in a future release.
     */
    LinkLocalIPv6Address: string;
    /**
     * LinkLocalIPv6PrefixLen is the prefix length of an IPv6 unicast address
     * Deprecated: This field is never set and will be removed in a future release.
     */
    LinkLocalIPv6PrefixLen: number /* int */;
    SecondaryIPAddresses: any /* network.Address */[]; // Deprecated: This field is never set and will be removed in a future release.
    SecondaryIPv6Addresses: any /* network.Address */[]; // Deprecated: This field is never set and will be removed in a future release.
}
/**
 * DefaultNetworkSettings holds network information
 * during the 2 release deprecation period.
 * It will be removed in Docker 1.11.
 */
export interface DefaultNetworkSettings {
    EndpointID: string; // EndpointID uniquely represents a service endpoint in a Sandbox
    Gateway: string; // Gateway holds the gateway address for the network
    GlobalIPv6Address: string; // GlobalIPv6Address holds network's global IPv6 address
    GlobalIPv6PrefixLen: number /* int */; // GlobalIPv6PrefixLen represents mask length of network's global IPv6 address
    IPAddress: string; // IPAddress holds the IPv4 address for the network
    IPPrefixLen: number /* int */; // IPPrefixLen represents mask length of network's IPv4 address
    IPv6Gateway: string; // IPv6Gateway holds gateway address specific for IPv6
    MacAddress: string; // MacAddress holds the MAC address for the network
}
/**
 * NetworkSettingsSummary provides a summary of container's networks
 * in /containers/json
 */
export interface NetworkSettingsSummary {
    Networks: { [key: string]: any /* network.EndpointSettings */ | undefined};
}

//////////
// source: options.go

/**
 * ResizeOptions holds parameters to resize a TTY.
 * It can be used to resize container TTYs and
 * exec process TTYs too.
 */
export interface ResizeOptions {
    Height: number /* uint */;
    Width: number /* uint */;
}
/**
 * AttachOptions holds parameters to attach to a container.
 */
export interface AttachOptions {
    Stream: boolean;
    Stdin: boolean;
    Stdout: boolean;
    Stderr: boolean;
    DetachKeys: string;
    Logs: boolean;
}
/**
 * CommitOptions holds parameters to commit changes into a container.
 */
export interface CommitOptions {
    Reference: string;
    Comment: string;
    Author: string;
    Changes: string[];
    Pause: boolean;
    Config?: Config;
}
/**
 * RemoveOptions holds parameters to remove containers.
 */
export interface RemoveOptions {
    RemoveVolumes: boolean;
    RemoveLinks: boolean;
    Force: boolean;
}
/**
 * StartOptions holds parameters to start containers.
 */
export interface StartOptions {
    CheckpointID: string;
    CheckpointDir: string;
}
/**
 * ListOptions holds parameters to list containers with.
 */
export interface ListOptions {
    Size: boolean;
    All: boolean;
    Latest: boolean;
    Since: string;
    Before: string;
    Limit: number /* int */;
    Filters: any /* filters.Args */;
}
/**
 * LogsOptions holds parameters to filter logs with.
 */
export interface LogsOptions {
    ShowStdout: boolean;
    ShowStderr: boolean;
    Since: string;
    Until: string;
    Timestamps: boolean;
    Follow: boolean;
    Tail: string;
    Details: boolean;
}

//////////
// source: port.go

/**
 * Port An open port on a container
 * swagger:model Port
 */
export interface Port {
    /**
     * Host IP address that the container's port is mapped to
     */
    IP?: string;
    /**
     * Port on the container
     * Required: true
     */
    PrivatePort: number /* uint16 */;
    /**
     * Port exposed on the host
     */
    PublicPort?: number /* uint16 */;
    /**
     * type
     * Required: true
     */
    Type: string;
}

//////////
// source: stats.go

/**
 * ThrottlingData stores CPU throttling stats of one running container.
 * Not used on Windows.
 */
export interface ThrottlingData {
    /**
     * Number of periods with throttling active
     */
    periods: number /* uint64 */;
    /**
     * Number of periods when the container hits its throttling limit.
     */
    throttled_periods: number /* uint64 */;
    /**
     * Aggregate time the container was throttled for in nanoseconds.
     */
    throttled_time: number /* uint64 */;
}
/**
 * CPUUsage stores All CPU stats aggregated since container inception.
 */
export interface CPUUsage {
    /**
     * Total CPU time consumed.
     * Units: nanoseconds (Linux)
     * Units: 100's of nanoseconds (Windows)
     */
    total_usage: number /* uint64 */;
    /**
     * Total CPU time consumed per core (Linux). Not used on Windows.
     * Units: nanoseconds.
     */
    percpu_usage?: number /* uint64 */[];
    /**
     * Time spent by tasks of the cgroup in kernel mode (Linux).
     * Time spent by all container processes in kernel mode (Windows).
     * Units: nanoseconds (Linux).
     * Units: 100's of nanoseconds (Windows). Not populated for Hyper-V Containers.
     */
    usage_in_kernelmode: number /* uint64 */;
    /**
     * Time spent by tasks of the cgroup in user mode (Linux).
     * Time spent by all container processes in user mode (Windows).
     * Units: nanoseconds (Linux).
     * Units: 100's of nanoseconds (Windows). Not populated for Hyper-V Containers
     */
    usage_in_usermode: number /* uint64 */;
}
/**
 * CPUStats aggregates and wraps all CPU related info of container
 */
export interface CPUStats {
    /**
     * CPU Usage. Linux and Windows.
     */
    cpu_usage: CPUUsage;
    /**
     * System Usage. Linux only.
     */
    system_cpu_usage?: number /* uint64 */;
    /**
     * Online CPUs. Linux only.
     */
    online_cpus?: number /* uint32 */;
    /**
     * Throttling Data. Linux only.
     */
    throttling_data?: ThrottlingData;
}
/**
 * MemoryStats aggregates all memory stats since container inception on Linux.
 * Windows returns stats for commit and private working set only.
 */
export interface MemoryStats {
    /**
     * current res_counter usage for memory
     */
    usage?: number /* uint64 */;
    /**
     * maximum usage ever recorded.
     */
    max_usage?: number /* uint64 */;
    /**
     * TODO(vishh): Export these as stronger types.
     * all the stats exported via memory.stat.
     */
    stats?: { [key: string]: number /* uint64 */};
    /**
     * number of times memory usage hits limits.
     */
    failcnt?: number /* uint64 */;
    limit?: number /* uint64 */;
    /**
     * committed bytes
     */
    commitbytes?: number /* uint64 */;
    /**
     * peak committed bytes
     */
    commitpeakbytes?: number /* uint64 */;
    /**
     * private working set
     */
    privateworkingset?: number /* uint64 */;
}
/**
 * BlkioStatEntry is one small entity to store a piece of Blkio stats
 * Not used on Windows.
 */
export interface BlkioStatEntry {
    major: number /* uint64 */;
    minor: number /* uint64 */;
    op: string;
    value: number /* uint64 */;
}
/**
 * BlkioStats stores All IO service stats for data read and write.
 * This is a Linux specific structure as the differences between expressing
 * block I/O on Windows and Linux are sufficiently significant to make
 * little sense attempting to morph into a combined structure.
 */
export interface BlkioStats {
    /**
     * number of bytes transferred to and from the block device
     */
    io_service_bytes_recursive: BlkioStatEntry[];
    io_serviced_recursive: BlkioStatEntry[];
    io_queue_recursive: BlkioStatEntry[];
    io_service_time_recursive: BlkioStatEntry[];
    io_wait_time_recursive: BlkioStatEntry[];
    io_merged_recursive: BlkioStatEntry[];
    io_time_recursive: BlkioStatEntry[];
    sectors_recursive: BlkioStatEntry[];
}
/**
 * StorageStats is the disk I/O stats for read/write on Windows.
 */
export interface StorageStats {
    read_count_normalized?: number /* uint64 */;
    read_size_bytes?: number /* uint64 */;
    write_count_normalized?: number /* uint64 */;
    write_size_bytes?: number /* uint64 */;
}
/**
 * NetworkStats aggregates the network stats of one container
 */
export interface NetworkStats {
    /**
     * Bytes received. Windows and Linux.
     */
    rx_bytes: number /* uint64 */;
    /**
     * Packets received. Windows and Linux.
     */
    rx_packets: number /* uint64 */;
    /**
     * Received errors. Not used on Windows. Note that we don't `omitempty` this
     * field as it is expected in the >=v1.21 API stats structure.
     */
    rx_errors: number /* uint64 */;
    /**
     * Incoming packets dropped. Windows and Linux.
     */
    rx_dropped: number /* uint64 */;
    /**
     * Bytes sent. Windows and Linux.
     */
    tx_bytes: number /* uint64 */;
    /**
     * Packets sent. Windows and Linux.
     */
    tx_packets: number /* uint64 */;
    /**
     * Sent errors. Not used on Windows. Note that we don't `omitempty` this
     * field as it is expected in the >=v1.21 API stats structure.
     */
    tx_errors: number /* uint64 */;
    /**
     * Outgoing packets dropped. Windows and Linux.
     */
    tx_dropped: number /* uint64 */;
    /**
     * Endpoint ID. Not used on Linux.
     */
    endpoint_id?: string;
    /**
     * Instance ID. Not used on Linux.
     */
    instance_id?: string;
}
/**
 * PidsStats contains the stats of a container's pids
 */
export interface PidsStats {
    /**
     * Current is the number of pids in the cgroup
     */
    current?: number /* uint64 */;
    /**
     * Limit is the hard limit on the number of pids in the cgroup.
     * A "Limit" of 0 means that there is no limit.
     */
    limit?: number /* uint64 */;
}
/**
 * Stats is Ultimate struct aggregating all types of stats of one container
 * Deprecated: use [StatsResponse] instead. This type will be removed in the next release.
 */
export type Stats = StatsResponse;
/**
 * StatsResponse aggregates all types of stats of one container.
 */
export interface StatsResponse {
    name?: string;
    id?: string;
    /**
     * Common stats
     */
    read: string;
    preread: string;
    /**
     * Linux specific stats, not populated on Windows.
     */
    pids_stats?: PidsStats;
    blkio_stats?: BlkioStats;
    /**
     * Windows specific stats, not populated on Linux.
     */
    num_procs: number /* uint32 */;
    storage_stats?: StorageStats;
    /**
     * Shared stats
     */
    cpu_stats?: CPUStats;
    precpu_stats?: CPUStats; // "Pre"="Previous"
    memory_stats?: MemoryStats;
    networks?: { [key: string]: NetworkStats};
}

//////////
// source: top_response.go

/**
 * TopResponse ContainerTopResponse
 * Container "top" response.
 * swagger:model TopResponse
 */
export interface TopResponse {
    /**
     * Each process running in the container, where each process
     * is an array of values corresponding to the titles.
     */
    Processes: string[][];
    /**
     * The ps column titles
     */
    Titles: string[];
}

//////////
// source: update_response.go

/**
 * UpdateResponse ContainerUpdateResponse
 * Response for a successful container-update.
 * swagger:model UpdateResponse
 */
export interface UpdateResponse {
    /**
     * Warnings encountered when updating the container.
     */
    Warnings: string[];
}

//////////
// source: wait_exit_error.go

/**
 * WaitExitError container waiting error, if any
 * swagger:model WaitExitError
 */
export interface WaitExitError {
    /**
     * Details of an error
     */
    Message?: string;
}

//////////
// source: wait_response.go

/**
 * WaitResponse ContainerWaitResponse
 * OK response to ContainerWait operation
 * swagger:model WaitResponse
 */
export interface WaitResponse {
    /**
     * error
     */
    Error?: WaitExitError;
    /**
     * Exit code of the container
     * Required: true
     */
    StatusCode: number /* int64 */;
}

//////////
// source: waitcondition.go

/**
 * WaitCondition is a type used to specify a container state for which
 * to wait.
 */
export type WaitCondition = string;
/**
 * Possible WaitCondition Values.
 * WaitConditionNotRunning (default) is used to wait for any of the non-running
 * states: "created", "exited", "dead", "removing", or "removed".
 * WaitConditionNextExit is used to wait for the next time the state changes
 * to a non-running state. If the state is currently "created" or "exited",
 * this would cause Wait() to block until either the container runs and exits
 * or is removed.
 * WaitConditionRemoved is used to wait for the container to be removed.
 */
export const WaitConditionNotRunning: WaitCondition = "not-running";
/**
 * Possible WaitCondition Values.
 * WaitConditionNotRunning (default) is used to wait for any of the non-running
 * states: "created", "exited", "dead", "removing", or "removed".
 * WaitConditionNextExit is used to wait for the next time the state changes
 * to a non-running state. If the state is currently "created" or "exited",
 * this would cause Wait() to block until either the container runs and exits
 * or is removed.
 * WaitConditionRemoved is used to wait for the container to be removed.
 */
export const WaitConditionNextExit: WaitCondition = "next-exit";
/**
 * Possible WaitCondition Values.
 * WaitConditionNotRunning (default) is used to wait for any of the non-running
 * states: "created", "exited", "dead", "removing", or "removed".
 * WaitConditionNextExit is used to wait for the next time the state changes
 * to a non-running state. If the state is currently "created" or "exited",
 * this would cause Wait() to block until either the container runs and exits
 * or is removed.
 * WaitConditionRemoved is used to wait for the container to be removed.
 */
export const WaitConditionRemoved: WaitCondition = "removed";
